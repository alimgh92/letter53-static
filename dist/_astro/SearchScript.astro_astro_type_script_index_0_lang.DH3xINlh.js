const re="ENTRIES",Y="KEYS",Z="VALUES";class O{constructor(e,t){const s=e._tree,n=Array.from(s.keys());this.set=e,this._type=t,this._path=n.length>0?[{node:s,keys:n}]:[]}next(){const e=this.dive();return this.backtrack(),e}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:e,keys:t}=E(this._path);if(E(t)==="")return{done:!1,value:this.result()};const s=e.get(E(t));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const e=E(this._path).keys;e.pop(),!(e.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:e})=>E(e)).filter(e=>e!=="").join("")}value(){return E(this._path).node.get("")}result(){switch(this._type){case Z:return this.value();case Y:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=o=>o[o.length-1],ce=(o,e,t)=>{const s=new Map;if(e===void 0)return s;const n=e.length+1,i=n+t,r=new Uint8Array(i*n).fill(t+1);for(let c=0;c<n;++c)r[c]=c;for(let c=1;c<i;++c)r[c*n]=c;return X(o,e,t,s,r,1,n,""),s},X=(o,e,t,s,n,i,r,c)=>{const d=i*r;e:for(const h of o.keys())if(h===""){const u=n[d-1];u<=t&&s.set(c,[o.get(h),u])}else{let u=i;for(let m=0;m<h.length;++m,++u){const l=h[m],g=r*u,_=g-r;let a=n[g];const f=Math.max(0,u-t-1),p=Math.min(r-1,u+t);for(let w=f;w<p;++w){const S=l!==e[w],x=n[_+w]+ +S,b=n[_+w+1]+1,I=n[g+w]+1,v=n[g+w+1]=Math.min(x,b,I);v<a&&(a=v)}if(a>t)continue e}X(o.get(h),e,t,s,n,u,r,c+h)}};class F{constructor(e=new Map,t=""){this._size=void 0,this._tree=e,this._prefix=t}atPrefix(e){if(!e.startsWith(this._prefix))throw new Error("Mismatched prefix");const[t,s]=A(this._tree,e.slice(this._prefix.length));if(t===void 0){const[n,i]=P(s);for(const r of n.keys())if(r!==""&&r.startsWith(i)){const c=new Map;return c.set(r.slice(i.length),n.get(r)),new F(c,e)}}return new F(t,e)}clear(){this._size=void 0,this._tree.clear()}delete(e){return this._size=void 0,ae(this._tree,e)}entries(){return new O(this,re)}forEach(e){for(const[t,s]of this)e(t,s,this)}fuzzyGet(e,t){return ce(this._tree,e,t)}get(e){const t=$(this._tree,e);return t!==void 0?t.get(""):void 0}has(e){const t=$(this._tree,e);return t!==void 0&&t.has("")}keys(){return new O(this,Y)}set(e,t){if(typeof e!="string")throw new Error("key must be a string");return this._size=void 0,V(this._tree,e).set("",t),this}get size(){if(this._size)return this._size;this._size=0;const e=this.entries();for(;!e.next().done;)this._size+=1;return this._size}update(e,t){if(typeof e!="string")throw new Error("key must be a string");this._size=void 0;const s=V(this._tree,e);return s.set("",t(s.get(""))),this}fetch(e,t){if(typeof e!="string")throw new Error("key must be a string");this._size=void 0;const s=V(this._tree,e);let n=s.get("");return n===void 0&&s.set("",n=t()),n}values(){return new O(this,Z)}[Symbol.iterator](){return this.entries()}static from(e){const t=new F;for(const[s,n]of e)t.set(s,n);return t}static fromObject(e){return F.from(Object.entries(e))}}const A=(o,e,t=[])=>{if(e.length===0||o==null)return[o,t];for(const s of o.keys())if(s!==""&&e.startsWith(s))return t.push([o,s]),A(o.get(s),e.slice(s.length),t);return t.push([o,e]),A(void 0,"",t)},$=(o,e)=>{if(e.length===0||o==null)return o;for(const t of o.keys())if(t!==""&&e.startsWith(t))return $(o.get(t),e.slice(t.length))},V=(o,e)=>{const t=e.length;e:for(let s=0;o&&s<t;){for(const i of o.keys())if(i!==""&&e[s]===i[0]){const r=Math.min(t-s,i.length);let c=1;for(;c<r&&e[s+c]===i[c];)++c;const d=o.get(i);if(c===i.length)o=d;else{const h=new Map;h.set(i.slice(c),d),o.set(e.slice(s,s+c),h),o.delete(i),o=h}s+=c;continue e}const n=new Map;return o.set(e.slice(s),n),n}return o},ae=(o,e)=>{const[t,s]=A(o,e);if(t!==void 0){if(t.delete(""),t.size===0)ee(s);else if(t.size===1){const[n,i]=t.entries().next().value;te(s,n,i)}}},ee=o=>{if(o.length===0)return;const[e,t]=P(o);if(e.delete(t),e.size===0)ee(o.slice(0,-1));else if(e.size===1){const[s,n]=e.entries().next().value;s!==""&&te(o.slice(0,-1),s,n)}},te=(o,e,t)=>{if(o.length===0)return;const[s,n]=P(o);s.set(n+e,t),s.delete(n)},P=o=>o[o.length-1],J="or",se="and",de="and_not";class L{constructor(e){if(e?.fields==null)throw new Error('MiniSearch: option "fields" must be provided');const t=e.autoVacuum==null||e.autoVacuum===!0?R:e.autoVacuum;this._options={...j,...e,autoVacuum:t,searchOptions:{...B,...e.searchOptions||{}},autoSuggestOptions:{...me,...e.autoSuggestOptions||{}}},this._index=new F,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=W,this.addFields(this._options.fields)}add(e){const{extractField:t,tokenize:s,processTerm:n,fields:i,idField:r}=this._options,c=t(e,r);if(c==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);if(this._idToShortId.has(c))throw new Error(`MiniSearch: duplicate ID ${c}`);const d=this.addDocumentId(c);this.saveStoredFields(d,e);for(const h of i){const u=t(e,h);if(u==null)continue;const m=s(u.toString(),h),l=this._fieldIds[h],g=new Set(m).size;this.addFieldLength(d,l,this._documentCount-1,g);for(const _ of m){const a=n(_,h);if(Array.isArray(a))for(const f of a)this.addTerm(l,d,f);else a&&this.addTerm(l,d,a)}}}addAll(e){for(const t of e)this.add(t)}addAllAsync(e,t={}){const{chunkSize:s=10}=t,n={chunk:[],promise:Promise.resolve()},{chunk:i,promise:r}=e.reduce(({chunk:c,promise:d},h,u)=>(c.push(h),(u+1)%s===0?{chunk:[],promise:d.then(()=>new Promise(m=>setTimeout(m,0))).then(()=>this.addAll(c))}:{chunk:c,promise:d}),n);return r.then(()=>this.addAll(i))}remove(e){const{tokenize:t,processTerm:s,extractField:n,fields:i,idField:r}=this._options,c=n(e,r);if(c==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);const d=this._idToShortId.get(c);if(d==null)throw new Error(`MiniSearch: cannot remove document with ID ${c}: it is not in the index`);for(const h of i){const u=n(e,h);if(u==null)continue;const m=t(u.toString(),h),l=this._fieldIds[h],g=new Set(m).size;this.removeFieldLength(d,l,this._documentCount,g);for(const _ of m){const a=s(_,h);if(Array.isArray(a))for(const f of a)this.removeTerm(l,d,f);else a&&this.removeTerm(l,d,a)}}this._storedFields.delete(d),this._documentIds.delete(d),this._idToShortId.delete(c),this._fieldLength.delete(d),this._documentCount-=1}removeAll(e){if(e)for(const t of e)this.remove(t);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new F,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(e){const t=this._idToShortId.get(e);if(t==null)throw new Error(`MiniSearch: cannot discard document with ID ${e}: it is not in the index`);this._idToShortId.delete(e),this._documentIds.delete(t),this._storedFields.delete(t),(this._fieldLength.get(t)||[]).forEach((s,n)=>{this.removeFieldLength(t,n,this._documentCount,s)}),this._fieldLength.delete(t),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:e,minDirtCount:t,batchSize:s,batchWait:n}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:n},{minDirtCount:t,minDirtFactor:e})}discardAll(e){const t=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const s of e)this.discard(s)}finally{this._options.autoVacuum=t}this.maybeAutoVacuum()}replace(e){const{idField:t,extractField:s}=this._options,n=s(e,t);this.discard(n),this.add(e)}vacuum(e={}){return this.conditionalVacuum(e)}conditionalVacuum(e,t){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&t,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const s=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=W,this.performVacuuming(e,s)}),this._enqueuedVacuum)):this.vacuumConditionsMet(t)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(e),this._currentVacuum)}async performVacuuming(e,t){const s=this._dirtCount;if(this.vacuumConditionsMet(t)){const n=e.batchSize||N.batchSize,i=e.batchWait||N.batchWait;let r=1;for(const[c,d]of this._index){for(const[h,u]of d)for(const[m]of u)this._documentIds.has(m)||(u.size<=1?d.delete(h):u.delete(m));this._index.get(c).size===0&&this._index.delete(c),r%n===0&&await new Promise(h=>setTimeout(h,i)),r+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(e){if(e==null)return!0;let{minDirtCount:t,minDirtFactor:s}=e;return t=t||R.minDirtCount,s=s||R.minDirtFactor,this.dirtCount>=t&&this.dirtFactor>=s}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(e){return this._idToShortId.has(e)}getStoredFields(e){const t=this._idToShortId.get(e);if(t!=null)return this._storedFields.get(t)}search(e,t={}){const{searchOptions:s}=this._options,n={...s,...t},i=this.executeQuery(e,t),r=[];for(const[c,{score:d,terms:h,match:u}]of i){const m=h.length||1,l={id:this._documentIds.get(c),score:d*m,terms:Object.keys(u),queryTerms:h,match:u};Object.assign(l,this._storedFields.get(c)),(n.filter==null||n.filter(l))&&r.push(l)}return e===L.wildcard&&n.boostDocument==null||r.sort(Q),r}autoSuggest(e,t={}){t={...this._options.autoSuggestOptions,...t};const s=new Map;for(const{score:i,terms:r}of this.search(e,t)){const c=r.join(" "),d=s.get(c);d!=null?(d.score+=i,d.count+=1):s.set(c,{score:i,terms:r,count:1})}const n=[];for(const[i,{score:r,terms:c,count:d}]of s)n.push({suggestion:i,terms:c,score:r/d});return n.sort(Q),n}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(e,t){if(t==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(e),t)}static async loadJSONAsync(e,t){if(t==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(e),t)}static getDefault(e){if(j.hasOwnProperty(e))return D(j,e);throw new Error(`MiniSearch: unknown option "${e}"`)}static loadJS(e,t){const{index:s,documentIds:n,fieldLength:i,storedFields:r,serializationVersion:c}=e,d=this.instantiateMiniSearch(e,t);d._documentIds=T(n),d._fieldLength=T(i),d._storedFields=T(r);for(const[h,u]of d._documentIds)d._idToShortId.set(u,h);for(const[h,u]of s){const m=new Map;for(const l of Object.keys(u)){let g=u[l];c===1&&(g=g.ds),m.set(parseInt(l,10),T(g))}d._index.set(h,m)}return d}static async loadJSAsync(e,t){const{index:s,documentIds:n,fieldLength:i,storedFields:r,serializationVersion:c}=e,d=this.instantiateMiniSearch(e,t);d._documentIds=await C(n),d._fieldLength=await C(i),d._storedFields=await C(r);for(const[u,m]of d._documentIds)d._idToShortId.set(m,u);let h=0;for(const[u,m]of s){const l=new Map;for(const g of Object.keys(m)){let _=m[g];c===1&&(_=_.ds),l.set(parseInt(g,10),await C(_))}++h%1e3===0&&await ne(0),d._index.set(u,l)}return d}static instantiateMiniSearch(e,t){const{documentCount:s,nextId:n,fieldIds:i,averageFieldLength:r,dirtCount:c,serializationVersion:d}=e;if(d!==1&&d!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const h=new L(t);return h._documentCount=s,h._nextId=n,h._idToShortId=new Map,h._fieldIds=i,h._avgFieldLength=r,h._dirtCount=c||0,h._index=new F,h}executeQuery(e,t={}){if(e===L.wildcard)return this.executeWildcardQuery(t);if(typeof e!="string"){const l={...t,...e,queries:void 0},g=e.queries.map(_=>this.executeQuery(_,l));return this.combineResults(g,l.combineWith)}const{tokenize:s,processTerm:n,searchOptions:i}=this._options,r={tokenize:s,processTerm:n,...i,...t},{tokenize:c,processTerm:d}=r,m=c(e).flatMap(l=>d(l)).filter(l=>!!l).map(fe(r)).map(l=>this.executeQuerySpec(l,r));return this.combineResults(m,r.combineWith)}executeQuerySpec(e,t){const s={...this._options.searchOptions,...t},n=(s.fields||this._options.fields).reduce((a,f)=>({...a,[f]:D(s.boost,f)||1}),{}),{boostDocument:i,weights:r,maxFuzzy:c,bm25:d}=s,{fuzzy:h,prefix:u}={...B.weights,...r},m=this._index.get(e.term),l=this.termResults(e.term,e.term,1,e.termBoost,m,n,i,d);let g,_;if(e.prefix&&(g=this._index.atPrefix(e.term)),e.fuzzy){const a=e.fuzzy===!0?.2:e.fuzzy,f=a<1?Math.min(c,Math.round(e.term.length*a)):a;f&&(_=this._index.fuzzyGet(e.term,f))}if(g)for(const[a,f]of g){const p=a.length-e.term.length;if(!p)continue;_?.delete(a);const w=u*a.length/(a.length+.3*p);this.termResults(e.term,a,w,e.termBoost,f,n,i,d,l)}if(_)for(const a of _.keys()){const[f,p]=_.get(a);if(!p)continue;const w=h*a.length/(a.length+p);this.termResults(e.term,a,w,e.termBoost,f,n,i,d,l)}return l}executeWildcardQuery(e){const t=new Map,s={...this._options.searchOptions,...e};for(const[n,i]of this._documentIds){const r=s.boostDocument?s.boostDocument(i,"",this._storedFields.get(n)):1;t.set(n,{score:r,terms:[],match:{}})}return t}combineResults(e,t=J){if(e.length===0)return new Map;const s=t.toLowerCase(),n=he[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map}toJSON(){const e=[];for(const[t,s]of this._index){const n={};for(const[i,r]of s)n[i]=Object.fromEntries(r);e.push([t,n])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:e,serializationVersion:2}}termResults(e,t,s,n,i,r,c,d,h=new Map){if(i==null)return h;for(const u of Object.keys(r)){const m=r[u],l=this._fieldIds[u],g=i.get(l);if(g==null)continue;let _=g.size;const a=this._avgFieldLength[l];for(const f of g.keys()){if(!this._documentIds.has(f)){this.removeTerm(l,f,t),_-=1;continue}const p=c?c(this._documentIds.get(f),t,this._storedFields.get(f)):1;if(!p)continue;const w=g.get(f),S=this._fieldLength.get(f)[l],x=le(w,_,this._documentCount,S,a,d),b=s*n*m*p*x,I=h.get(f);if(I){I.score+=b,ge(I.terms,e);const v=D(I.match,t);v?v.push(u):I.match[t]=[u]}else h.set(f,{score:b,terms:[e],match:{[t]:[u]}})}}return h}addTerm(e,t,s){const n=this._index.fetch(s,K);let i=n.get(e);if(i==null)i=new Map,i.set(t,1),n.set(e,i);else{const r=i.get(t);i.set(t,(r||0)+1)}}removeTerm(e,t,s){if(!this._index.has(s)){this.warnDocumentChanged(t,e,s);return}const n=this._index.fetch(s,K),i=n.get(e);i==null||i.get(t)==null?this.warnDocumentChanged(t,e,s):i.get(t)<=1?i.size<=1?n.delete(e):i.delete(t):i.set(t,i.get(t)-1),this._index.get(s).size===0&&this._index.delete(s)}warnDocumentChanged(e,t,s){for(const n of Object.keys(this._fieldIds))if(this._fieldIds[n]===t){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(e)} has changed before removal: term "${s}" was not present in field "${n}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(e){const t=this._nextId;return this._idToShortId.set(e,t),this._documentIds.set(t,e),this._documentCount+=1,this._nextId+=1,t}addFields(e){for(let t=0;t<e.length;t++)this._fieldIds[e[t]]=t}addFieldLength(e,t,s,n){let i=this._fieldLength.get(e);i==null&&this._fieldLength.set(e,i=[]),i[t]=n;const c=(this._avgFieldLength[t]||0)*s+n;this._avgFieldLength[t]=c/(s+1)}removeFieldLength(e,t,s,n){if(s===1){this._avgFieldLength[t]=0;return}const i=this._avgFieldLength[t]*s-n;this._avgFieldLength[t]=i/(s-1)}saveStoredFields(e,t){const{storeFields:s,extractField:n}=this._options;if(s==null||s.length===0)return;let i=this._storedFields.get(e);i==null&&this._storedFields.set(e,i={});for(const r of s){const c=n(t,r);c!==void 0&&(i[r]=c)}}}L.wildcard=Symbol("*");const D=(o,e)=>Object.prototype.hasOwnProperty.call(o,e)?o[e]:void 0,he={[J]:(o,e)=>{for(const t of e.keys()){const s=o.get(t);if(s==null)o.set(t,e.get(t));else{const{score:n,terms:i,match:r}=e.get(t);s.score=s.score+n,s.match=Object.assign(s.match,r),U(s.terms,i)}}return o},[se]:(o,e)=>{const t=new Map;for(const s of e.keys()){const n=o.get(s);if(n==null)continue;const{score:i,terms:r,match:c}=e.get(s);U(n.terms,r),t.set(s,{score:n.score+i,terms:n.terms,match:Object.assign(n.match,c)})}return t},[de]:(o,e)=>{for(const t of e.keys())o.delete(t);return o}},ue={k:1.2,b:.7,d:.5},le=(o,e,t,s,n,i)=>{const{k:r,b:c,d}=i;return Math.log(1+(t-e+.5)/(e+.5))*(d+o*(r+1)/(o+r*(1-c+c*s/n)))},fe=o=>(e,t,s)=>{const n=typeof o.fuzzy=="function"?o.fuzzy(e,t,s):o.fuzzy||!1,i=typeof o.prefix=="function"?o.prefix(e,t,s):o.prefix===!0,r=typeof o.boostTerm=="function"?o.boostTerm(e,t,s):1;return{term:e,fuzzy:n,prefix:i,termBoost:r}},j={idField:"id",extractField:(o,e)=>o[e],tokenize:o=>o.split(pe),processTerm:o=>o.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(o,e)=>{typeof console?.[o]=="function"&&console[o](e)},autoVacuum:!0},B={combineWith:J,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:ue},me={combineWith:se,prefix:(o,e,t)=>e===t.length-1},N={batchSize:1e3,batchWait:10},W={minDirtFactor:.1,minDirtCount:20},R={...N,...W},ge=(o,e)=>{o.includes(e)||o.push(e)},U=(o,e)=>{for(const t of e)o.includes(t)||o.push(t)},Q=({score:o},{score:e})=>e-o,K=()=>new Map,T=o=>{const e=new Map;for(const t of Object.keys(o))e.set(parseInt(t,10),o[t]);return e},C=async o=>{const e=new Map;let t=0;for(const s of Object.keys(o))e.set(parseInt(s,10),o[s]),++t%1e3===0&&await ne(0);return e},ne=o=>new Promise(e=>setTimeout(e,o)),pe=/[\n\r\p{Z}\p{P}]+/u;function ie(o){return o.replace(/ي/g,"ی").replace(/ى/g,"ی").replace(/ك/g,"ک").replace(/ة/g,"ه").replace(/ۀ/g,"ه").replace(/أ|إ|آ|ٱ/g,"ا").replace(/ؤ/g,"و").replace(/ئ/g,"ی").replace(/[\u064B-\u065F\u0670]/g,"").replace(/ـ/g,"").replace(/\s+/g," ").trim()}function _e(o){return o.replace(/\u200C/g," ").replace(/می\s+/g,"می").replace(/نمی\s+/g,"نمی")}function H(o){let e=ie(o);return e=_e(e),e.split(/[\s\-_،؛؟:.!?«»""''()[\]{}\/\\]+/).map(s=>s.trim()).filter(s=>s.length>1).filter(s=>!Se(s))}const we=new Set(["و","در","به","از","که","این","آن","با","برای","است","بود","را","تا","بر","هم","می","یا","اما","اگر","چون","ولی","ال","من","الی","فی","علی","هذا","ذلك","التی","الذی"]);function Se(o){return we.has(o)}function q(o){return ie(o).toLowerCase()}class ye{miniSearch=null;initialized=!1;documents=new Map;async initialize(e=!1){if(!(this.initialized&&!e))try{const t=await fetch("/api/search-index.json",{cache:"reload"});if(!t.ok)throw new Error("Failed to fetch search index");const s=await t.json(),n={fields:["title","content","description"],storeFields:["title","slug","chapter","lang","description","content"],tokenize:i=>H(i),processTerm:i=>q(i)};typeof s.data=="string"?this.miniSearch=L.loadJSON(s.data,n):this.miniSearch=L.loadJS(s.data,n),s.documents&&s.documents.forEach(i=>{this.documents.set(i.id,i)}),this.initialized=!0;try{localStorage.setItem("searchIndexData",JSON.stringify(s)),localStorage.setItem("searchIndexVersion",s.version)}catch{}"serviceWorker"in navigator&&"sync"in window.ServiceWorkerRegistration.prototype&&navigator.serviceWorker.ready.then(i=>i.sync.register("search-index-sync")).catch(i=>{})}catch{const s=localStorage.getItem("searchIndexData");if(s)try{const n=JSON.parse(s),i={fields:["title","content","description"],storeFields:["title","slug","chapter","lang","description","content"],tokenize:r=>H(r),processTerm:r=>q(r)};typeof n.data=="string"?this.miniSearch=L.loadJSON(n.data,i):this.miniSearch=L.loadJS(n.data,i),n.documents&&n.documents.forEach(r=>{this.documents.set(r.id,r)}),this.initialized=!0}catch{}}}search(e){if(!this.miniSearch)return[];try{return this.miniSearch.search(e,{fuzzy:.15,prefix:!0,boost:{title:2,description:1.2}}).map(n=>{const i=this.documents.get(n.id);return i?{...n,...i}:n})}catch{return[]}}suggest(e){if(!this.miniSearch)return[];try{return this.miniSearch.autoSuggest(e,{fuzzy:.15,prefix:!0}).map(t=>t.suggestion)}catch{return[]}}}const G=new ye;document.addEventListener("DOMContentLoaded",async()=>{const o=document.getElementById("search-modal"),e=document.getElementById("search-btn"),t=document.getElementById("search-close"),s=document.getElementById("search-input"),n=document.getElementById("search-results");let i=-1,r=[],c=!1;async function d(){if(!c)try{await G.initialize(),c=!0}catch{}}function h(){o?.classList.add("active"),o?.setAttribute("aria-hidden","false"),o?.setAttribute("tabindex","-1"),d(),setTimeout(()=>s?.focus(),150)}function u(){o?.classList.remove("active"),o?.setAttribute("aria-hidden","true"),s.value="",n.innerHTML='<div class="search-placeholder">هرآنچه دنبالش هستید را بنویسید...</div>',i=-1}function m(a){if(!a||a.length<2){n.innerHTML='<div class="search-placeholder">حداقل ۲ حرف تایپ کنید...</div>',i=-1,r=[];return}if(!c){n.innerHTML='<div class="search-placeholder">در حال بارگذاری...</div>',d();return}try{if(r=G.search(a),r.length===0){n.innerHTML='<div class="search-placeholder">نتیجه‌ای یافت نشد</div>',i=-1;return}i=-1;const f=r.map((p,w)=>{const S=p.content||p.description||"",x=z=>z.replace(/ي/g,"ی").replace(/ى/g,"ی").replace(/ك/g,"ک").replace(/ة/g,"ه").replace(/ۀ/g,"ه"),b=x(S.toLowerCase()),I=x(a.toLowerCase());let v;b.includes(I)?v=[a]:v=p.terms||[a];let y=S,M=-1;for(const z of v){const k=S.toLowerCase().indexOf(z.toLowerCase());if(k!==-1){M=k;break}}if(M!==-1){const z=Math.max(0,M-100),k=Math.min(S.length,M+150);y=S.substring(z,k),z>0&&(y="..."+y),k<S.length&&(y=y+"...")}else y=S.substring(0,250),S.length>250&&(y+="...");for(const z of v){const k=new RegExp(`(${z})`,"gi");y=y.replace(k,"<mark>$1</mark>")}if(!y.includes("<mark>")){const z=new RegExp(`(${a})`,"gi");y=y.replace(z,"<mark>$1</mark>")}const oe=v.join(",");return`
            <div class="search-result-item" data-index="${w}" data-slug="${p.slug}" data-matched-terms="${oe}">
              <div class="search-result-title">
                <strong>${p.title}</strong>
              </div>
              <div class="search-result-content">${y}</div>
            </div>
          `}).join("");if(n.innerHTML=f,r.length>0){const p=document.createElement("div");p.className="search-keyboard-hint",p.innerHTML="<span>↑↓ حرکت</span> <span>Enter انتخاب</span> <span>Esc بستن</span>",n.appendChild(p)}document.querySelectorAll(".search-result-item").forEach(p=>{p.addEventListener("click",()=>{const w=p.getAttribute("data-slug"),S=p.getAttribute("data-matched-terms");if(w&&S){const x=new URLSearchParams;x.set("highlight",S),window.location.href=`/chapters/${w}?${x.toString()}`}})})}catch{n.innerHTML='<div class="search-placeholder">خطا در جستجو</div>'}}function l(a){if(o?.classList.contains("active"))if(a.key==="ArrowDown")a.preventDefault(),a.stopPropagation(),r.length>0&&(i=i<r.length-1?i+1:i,g());else if(a.key==="ArrowUp")a.preventDefault(),a.stopPropagation(),r.length>0&&(i=i>0?i-1:-1,g());else if(a.key==="Enter"&&i>=0){a.preventDefault();const f=document.querySelector(".search-result-item.selected");if(f){const p=f.getAttribute("data-slug"),w=f.getAttribute("data-matched-terms");if(p&&w){const S=new URLSearchParams;S.set("highlight",w),window.location.href=`/chapters/${p}?${S.toString()}`}}}else a.key==="Escape"&&u()}function g(){document.querySelectorAll(".search-result-item").forEach((f,p)=>{p===i?(f.classList.add("selected"),f.scrollIntoView({block:"nearest"})):f.classList.remove("selected")})}e?.addEventListener("click",h),t?.addEventListener("click",u);let _;s?.addEventListener("input",a=>{const f=a.target.value;clearTimeout(_),_=setTimeout(()=>m(f),300)}),o?.addEventListener("click",a=>{a.target===o&&u()}),document.addEventListener("keydown",a=>{(a.ctrlKey||a.metaKey)&&!a.shiftKey&&(a.key==="k"||a.key==="K")&&(a.preventDefault(),h()),o?.classList.contains("active")&&l(a)})});
